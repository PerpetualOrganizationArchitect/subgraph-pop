# Schema version: 1.1.0
type Organization @entity(immutable: false) {
  id: Bytes! # orgId
  # Contract relationships - nullable because OrgRegistered creates org before OrgDeployed adds contracts
  executorContract: ExecutorContract
  hybridVoting: HybridVotingContract
  directDemocracyVoting: DirectDemocracyVotingContract
  quickJoin: QuickJoinContract
  participationToken: ParticipationTokenContract
  taskManager: TaskManager
  educationHub: EducationHubContract
  paymentManager: PaymentManagerContract
  eligibilityModule: EligibilityModuleContract
  toggleModuleContract: ToggleModuleContract
  # Deployment data - nullable until OrgDeployed event
  topHatId: BigInt
  roleHatIds: [BigInt!]
  deployedAt: BigInt
  deployedAtBlock: BigInt
  transactionHash: Bytes
  users: [User!]! @derivedFrom(field: "organization")
  # Consolidated entity references
  hatPermissions: [HatPermission!]! @derivedFrom(field: "organization")
  executorChanges: [ExecutorChange!]! @derivedFrom(field: "organization")
  pauseEvents: [PauseEvent!]! @derivedFrom(field: "organization")
  # From OrgRegistry - org name and metadata
  name: String
  metadataHash: Bytes
  metadata: OrgMetadata # IPFS-indexed metadata content (may be null if IPFS unavailable)
  lastUpdatedAt: BigInt
  metaUpdates: [OrgMetaUpdate!]! @derivedFrom(field: "organization")
  registeredContracts: [RegisteredContract!]! @derivedFrom(field: "organization")
  roles: [Role!]! @derivedFrom(field: "organization")
}

# ========================================
# User - Aggregates all user activities within an organization
# ========================================

type User @entity(immutable: false) {
  id: String! # orgId-userAddress
  organization: Organization!
  address: Bytes!
  account: Account # Link to global Account for username
  username: String # Denormalized from account for convenience

  # Membership tracking
  joinMethod: String # "QuickJoin", "HatClaim", "VouchingAutoMint", "ExecutorMint"
  currentHatIds: [BigInt!]! # Currently held hats
  membershipStatus: MembershipStatus! # Active/Inactive
  hatChanges: [UserHatChange!]! @derivedFrom(field: "user")

  # Token balances
  participationTokenBalance: BigInt!

  # Activity relationships
  assignedTasks: [Task!]! @derivedFrom(field: "assigneeUser")
  completedTasks: [Task!]! @derivedFrom(field: "completerUser")
  cancelledTasks: [Task!]! @derivedFrom(field: "cancellerUser")
  taskApplications: [TaskApplication!]! @derivedFrom(field: "applicantUser")
  approvedApplications: [TaskApplication!]! @derivedFrom(field: "approverUser")
  hybridVotes: [Vote!]! @derivedFrom(field: "voterUser")
  ddvVotes: [DDVVote!]! @derivedFrom(field: "voterUser")
  hybridProposalsCreated: [Proposal!]! @derivedFrom(field: "creatorUser")
  modulesCompleted: [ModuleCompletion!]! @derivedFrom(field: "learnerUser")
  tokenRequests: [TokenRequest!]! @derivedFrom(field: "requesterUser")
  approvedTokenRequests: [TokenRequest!]! @derivedFrom(field: "approverUser")
  claims: [Claim!]! @derivedFrom(field: "claimerUser")
  payments: [Payment!]! @derivedFrom(field: "payerUser")
  quickJoinEvents: [QuickJoinEvent!]! @derivedFrom(field: "userUser")
  hatsCreated: [Hat!]! @derivedFrom(field: "creatorUser")
  wearerEligibilities: [WearerEligibility!]! @derivedFrom(field: "wearerUser")
  vouchesGiven: [Vouch!]! @derivedFrom(field: "voucherUser")
  vouchesReceived: [Vouch!]! @derivedFrom(field: "wearerUser")
  hatsMintedEvents: [HatsMintedEvent!]! @derivedFrom(field: "recipientUser")
  vouchingRestrictions: [VouchingRestrictionEvent!]! @derivedFrom(field: "userUser")
  hatAutoMints: [HatAutoMintEvent!]! @derivedFrom(field: "wearerUser")
  hatClaims: [HatClaimEvent!]! @derivedFrom(field: "wearerUser")

  # Aggregate statistics
  totalVotes: BigInt!
  totalTasksCompleted: BigInt!
  totalTasksCancelled: BigInt!
  totalModulesCompleted: BigInt!
  totalClaimsAmount: BigInt!
  totalPaymentsAmount: BigInt!
  totalTokenRequestsAmount: BigInt!

  # Timestamps
  firstSeenAt: BigInt!
  firstSeenAtBlock: BigInt!
  lastActiveAt: BigInt!
  lastActiveAtBlock: BigInt!
}

type TaskManager @entity(immutable: false) {
  id: Bytes! # taskManager contract address
  organization: Organization! # Organization this TaskManager belongs to
  projects: [Project!]! @derivedFrom(field: "taskManager")
  creatorHatIds: [BigInt!]! # Hat IDs that can create projects (derived from org config)
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
}

type BeaconUpgrade @entity(immutable: true) {
  id: Bytes!
  implementation: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type GovernanceModule @entity(immutable: true) {
  id: Bytes! # proxy address
  orgId: Bytes!
  typeId: Bytes!
  proxy: Bytes!
  beacon: Bytes!
  autoUpgrade: Boolean!
  owner: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Project @entity(immutable: false) {
  id: String! # taskManager-projectId (composite key for cross-org isolation)
  projectId: Bytes! # raw projectId from contract
  taskManager: TaskManager! # Relationship to TaskManager entity
  title: String! # project title
  metadataHash: Bytes! # project metadata hash
  cap: BigInt!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  deleted: Boolean!
  deletedAt: BigInt
  tasks: [Task!]! @derivedFrom(field: "project")
  # Project permissions and caps
  managers: [ProjectManager!]! @derivedFrom(field: "project")
  rolePermissions: [ProjectRolePermission!]! @derivedFrom(field: "project")
  bountyCaps: [ProjectBountyCap!]! @derivedFrom(field: "project")
  capChanges: [ProjectCapChange!]! @derivedFrom(field: "project")
}

# ========================================
# Project Permissions and Caps Entities
# ========================================

type ProjectManager @entity(immutable: false) {
  id: String! # taskManager-projectId-managerAddress (composite key)
  project: Project!
  manager: Bytes!
  managerUser: User
  isActive: Boolean! # true if currently a manager, false if removed
  addedAt: BigInt!
  addedAtBlock: BigInt!
  removedAt: BigInt
  removedAtBlock: BigInt
  lastUpdatedAt: BigInt!
  transactionHash: Bytes!
}

type ProjectRolePermission @entity(immutable: false) {
  id: String! # taskManager-projectId-hatId (composite key)
  project: Project!
  hatId: BigInt!
  mask: Int! # Permission bitmask (uint8: create=1, claim=2, review=4, assign=8)
  canCreate: Boolean! # mask & 1
  canClaim: Boolean! # mask & 2
  canReview: Boolean! # mask & 4
  canAssign: Boolean! # mask & 8
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

type ProjectBountyCap @entity(immutable: false) {
  id: String! # taskManager-projectId-tokenAddress (composite key)
  project: Project!
  token: Bytes! # ERC-20 token address
  cap: BigInt! # Current cap amount
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
  capChanges: [BountyCapChange!]! @derivedFrom(field: "bountyCap")
}

type ProjectCapChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  project: Project!
  oldCap: BigInt!
  newCap: BigInt!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

type BountyCapChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  bountyCap: ProjectBountyCap!
  project: Project!
  token: Bytes!
  oldCap: BigInt!
  newCap: BigInt!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# Consolidated Enums
# ========================================

enum ContractType {
  HybridVoting
  DirectDemocracyVoting
  ParticipationToken
  QuickJoin
  EducationHub
  Executor
  ToggleModule
}

enum HatPermissionRole {
  Voter
  Creator
  Member
  Approver
}

enum MembershipStatus {
  Active
  Inactive
}

# ========================================
# Task Enums
# ========================================

enum TaskStatus {
  Open
  Assigned
  Submitted
  Completed
  Cancelled
}

type Task @entity(immutable: false) {
  id: String! # taskManager-taskId
  taskId: BigInt!
  taskManager: Bytes!
  project: Project! # References composite Project ID (taskManager-projectId)
  payout: BigInt!
  bountyToken: Bytes!
  bountyPayout: BigInt!
  requiresApplication: Boolean!
  title: String! # task title
  metadataHash: Bytes! # task metadata hash
  assignee: Bytes
  assigneeUsername: String
  assigneeUser: User
  completer: Bytes
  completerUsername: String
  completerUser: User
  canceller: Bytes
  cancellerUsername: String
  cancellerUser: User
  status: TaskStatus!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  assignedAt: BigInt
  submittedAt: BigInt
  completedAt: BigInt
  cancelledAt: BigInt
  updatedAt: BigInt
  applications: [TaskApplication!]! @derivedFrom(field: "task")
}

type TaskApplication @entity(immutable: false) {
  id: String! # taskManager-taskId-applicant
  task: Task!
  applicant: Bytes!
  applicantUsername: String
  applicantUser: User
  applicationHash: Bytes!
  approved: Boolean!
  approver: Bytes
  approverUsername: String
  approverUser: User
  appliedAt: BigInt!
  appliedAtBlock: BigInt!
  approvedAt: BigInt
}

# HybridVoting Entities

type HybridVotingContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization! # Organization this HybridVotingContract belongs to
  executor: Bytes!
  quorum: Int!
  hats: Bytes!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  classVersion: BigInt! # Current class configuration version (block number)
  targetPermissions: [HybridVotingTargetPermission!]! @derivedFrom(field: "hybridVoting")
  quorumChanges: [HybridVotingQuorumChange!]! @derivedFrom(field: "hybridVoting")
  proposals: [Proposal!]! @derivedFrom(field: "hybridVoting")
  votingClasses: [VotingClass!]! @derivedFrom(field: "hybridVoting")
  classChanges: [VotingClassChange!]! @derivedFrom(field: "hybridVoting")
}

# Enum for voting class strategy
enum VotingClassStrategy {
  DIRECT      # 1 person = 100 raw points
  ERC20_BAL   # Token balance-based voting
}

# Voting class configuration for hybrid voting
type VotingClass @entity(immutable: false) {
  id: String!                    # hybridVoting-version-classIndex
  hybridVoting: HybridVotingContract!
  version: BigInt!               # Class config version (block number)
  classIndex: Int!               # Index in the classes array (0-7)
  strategy: VotingClassStrategy! # DIRECT or ERC20_BAL
  slicePct: Int!                 # 1-100, percentage of total voting power
  quadratic: Boolean!            # If true, use sqrt for token balances
  minBalance: BigInt!            # Minimum balance required (for ERC20_BAL)
  asset: Bytes!                  # ERC20 token address (zero for DIRECT)
  hatIds: [BigInt!]!             # Hat IDs that can vote in this class
  isActive: Boolean!             # True if this is the current version
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
}

# Immutable record of class configuration changes
type VotingClassChange @entity(immutable: true) {
  id: Bytes!                     # txHash-logIndex
  hybridVoting: HybridVotingContract!
  version: BigInt!               # Block number used as version
  classesHash: Bytes!            # Hash of the classes array
  numClasses: Int!               # Number of classes in this version
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

type HybridVotingTargetPermission @entity(immutable: false) {
  id: String! # contractAddress-targetAddress
  hybridVoting: HybridVotingContract!
  target: Bytes!
  allowed: Boolean!
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

type HybridVotingQuorumChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  hybridVoting: HybridVotingContract!
  newQuorum: Int!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# Proposal status enum
enum ProposalStatus {
  Active
  Ended
  Executed
}

type Proposal @entity(immutable: false) {
  id: String! # hybridVoting-proposalId
  proposalId: BigInt!
  hybridVoting: HybridVotingContract!
  creator: Bytes! # from transaction.from
  creatorUsername: String
  creatorUser: User
  title: String! # proposal title
  descriptionHash: Bytes! # hash of proposal description
  numOptions: Int!
  startTimestamp: BigInt!
  endTimestamp: BigInt!
  isHatRestricted: Boolean! # true for NewHatProposal, false for NewProposal
  restrictedHatIds: [BigInt!] # only for hat-restricted proposals
  status: ProposalStatus!
  votes: [Vote!]! @derivedFrom(field: "proposal")
  batchExecutions: [BatchExecution!]! @derivedFrom(field: "hybridProposal") # Link to executions
  winningOption: BigInt
  isValid: Boolean
  wasExecuted: Boolean!
  winnerAnnouncedAt: BigInt
  executedAt: BigInt
  executedCallsCount: BigInt
  createdAtBlock: BigInt!
  transactionHash: Bytes!
}

type Vote @entity(immutable: true) {
  id: String! # hybridVoting-proposalId-voter
  proposal: Proposal!
  voter: Bytes!
  voterUsername: String
  voterUser: User
  optionIndexes: [Int!]! # Vote distribution across options
  optionWeights: [Int!]! # Weight for each option (percentages)
  classRawPowers: [BigInt!]! # Raw voting power per class
  votedAt: BigInt!
  votedAtBlock: BigInt!
  transactionHash: Bytes!
}

# DirectDemocracyVoting Entities

type DirectDemocracyVotingContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization! # Organization this DirectDemocracyVotingContract belongs to
  executor: Bytes!
  quorumPercentage: Int!
  hats: Bytes!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  targetPermissions: [DirectDemocracyVotingTargetPermission!]! @derivedFrom(field: "directDemocracyVoting")
  quorumChanges: [DirectDemocracyVotingQuorumChange!]! @derivedFrom(field: "directDemocracyVoting")
  ddvProposals: [DDVProposal!]! @derivedFrom(field: "directDemocracyVoting")
}

type DirectDemocracyVotingTargetPermission @entity(immutable: false) {
  id: String! # contractAddress-targetAddress
  directDemocracyVoting: DirectDemocracyVotingContract!
  target: Bytes!
  allowed: Boolean!
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

type DirectDemocracyVotingQuorumChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  directDemocracyVoting: DirectDemocracyVotingContract!
  newQuorumPercentage: Int!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# DDV Proposal status enum
enum DDVProposalStatus {
  Active
  Ended
  Cleaned
}

type DDVProposal @entity(immutable: false) {
  id: String! # directDemocracyVoting-proposalId
  proposalId: BigInt!
  directDemocracyVoting: DirectDemocracyVotingContract!
  title: String! # proposal title
  descriptionHash: Bytes! # hash of proposal description
  numOptions: Int!
  startTimestamp: BigInt!
  endTimestamp: BigInt!
  isHatRestricted: Boolean! # true for NewHatProposal, false for NewProposal
  restrictedHatIds: [BigInt!] # only for hat-restricted proposals
  status: DDVProposalStatus!
  votes: [DDVVote!]! @derivedFrom(field: "proposal")
  batchExecutions: [BatchExecution!]! @derivedFrom(field: "ddvProposal") # Link to executions
  winningOption: BigInt
  isValid: Boolean
  winnerAnnouncedAt: BigInt
  cleanedAt: BigInt
  createdAtBlock: BigInt!
  transactionHash: Bytes!
}

type DDVVote @entity(immutable: true) {
  id: String! # directDemocracyVoting-proposalId-voter
  proposal: DDVProposal!
  voter: Bytes!
  voterUsername: String
  voterUser: User
  optionIndexes: [Int!]! # Vote distribution across options
  optionWeights: [Int!]! # Weight for each option (percentages)
  votedAt: BigInt!
  votedAtBlock: BigInt!
  transactionHash: Bytes!
}

# EligibilityModule Entities

type EligibilityModuleContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization! # Organization this EligibilityModuleContract belongs to
  superAdmin: Bytes!
  hatsContract: Bytes!
  toggleModule: Bytes!
  eligibilityModuleAdminHat: BigInt
  isPaused: Boolean!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  hats: [Hat!]! @derivedFrom(field: "eligibilityModule")
  wearerEligibilities: [WearerEligibility!]! @derivedFrom(field: "eligibilityModule")
  vouchConfigs: [VouchConfig!]! @derivedFrom(field: "eligibilityModule")
  vouches: [Vouch!]! @derivedFrom(field: "eligibilityModule")
  userJoinTimes: [UserJoinTime!]! @derivedFrom(field: "eligibilityModule")
  vouchingRestrictions: [VouchingRestrictionEvent!]! @derivedFrom(field: "eligibilityModule")
  hatAutoMints: [HatAutoMintEvent!]! @derivedFrom(field: "eligibilityModule")
  hatClaims: [HatClaimEvent!]! @derivedFrom(field: "eligibilityModule")
}

type Hat @entity(immutable: false) {
  id: String! # eligibilityModule-hatId
  hatId: BigInt!
  parentHatId: BigInt!
  parentHat: Hat # Link to parent Hat entity for hierarchy traversal
  childHats: [Hat!]! @derivedFrom(field: "parentHat") # Derived children
  level: Int! # Depth in hierarchy (topHat = 0)
  eligibilityModule: EligibilityModuleContract!
  creator: Bytes!
  creatorUser: User
  creatorUsername: String
  defaultEligible: Boolean!
  defaultStanding: Boolean!
  mintedCount: BigInt!
  # Metadata fields
  name: String # Role name from metadata update
  metadataCID: Bytes # IPFS CID for extended role metadata JSON
  metadata: HatMetadata # Link to IPFS-indexed metadata content
  metadataUpdatedAt: BigInt
  metadataUpdatedAtBlock: BigInt
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
  wearers: [WearerEligibility!]! @derivedFrom(field: "hat")
  vouchConfig: VouchConfig @derivedFrom(field: "hat")
  role: Role @derivedFrom(field: "hat")
  metadataUpdates: [HatMetadataUpdateEvent!]! @derivedFrom(field: "hat")
}

# ========================================
# Role - Organization-centric view of hats
# Aggregates permissions and wearers for a hat within an organization
# ========================================

type Role @entity(immutable: false) {
  id: String! # orgId-hatId
  organization: Organization!
  hatId: BigInt!
  hat: Hat # Link to Hat entity (nullable until HatCreatedWithEligibility)

  # Role metadata from RolesCreated event
  name: String # Role name from smart contract
  image: String # Role image URL
  metadataCID: Bytes # IPFS CID for extended metadata
  canVote: Boolean # Whether this role can vote
  isUserRole: Boolean # True for user-defined roles (in roleHatIds), false for system hats (TopHat, AdminHat)

  # Timestamps
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!

  # Derived relationships
  permissions: [HatPermission!]! @derivedFrom(field: "role")
  wearers: [RoleWearer!]! @derivedFrom(field: "role")
}

type RoleWearer @entity(immutable: false) {
  id: String! # orgId-hatId-wearer
  role: Role!
  user: User!
  wearer: Bytes!
  wearerUsername: String

  # Link to WearerEligibility if available (for eligibility status)
  wearerEligibility: WearerEligibility

  # Timestamps
  addedAt: BigInt!
  addedAtBlock: BigInt!
  removedAt: BigInt
  isActive: Boolean!
  transactionHash: Bytes!
}

type WearerEligibility @entity(immutable: false) {
  id: String! # eligibilityModule-hatId-wearer
  eligibilityModule: EligibilityModuleContract!
  hat: Hat!
  wearer: Bytes!
  wearerUser: User
  wearerUsername: String
  hatId: BigInt!
  eligible: Boolean!
  standing: Boolean!
  hasSpecificRules: Boolean! # true if this wearer has custom rules, false if using defaults
  admin: Bytes # admin who set the eligibility
  adminUser: User
  adminUsername: String
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
  vouches: [Vouch!]! @derivedFrom(field: "wearerEligibility")
}

type VouchConfig @entity(immutable: false) {
  id: String! # eligibilityModule-hatId
  eligibilityModule: EligibilityModuleContract!
  hat: Hat!
  hatId: BigInt!
  quorum: Int!
  membershipHatId: BigInt!
  enabled: Boolean!
  combinesWithHierarchy: Boolean!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
  vouches: [Vouch!]! @derivedFrom(field: "vouchConfig")
}

type Vouch @entity(immutable: false) {
  id: String! # eligibilityModule-hatId-wearer-voucher
  eligibilityModule: EligibilityModuleContract!
  vouchConfig: VouchConfig!
  wearerEligibility: WearerEligibility!
  hatId: BigInt!
  wearer: Bytes!
  wearerUser: User
  wearerUsername: String
  voucher: Bytes!
  voucherUser: User
  voucherUsername: String
  vouchCount: Int! # current count after this vouch
  isActive: Boolean! # false if revoked
  createdAt: BigInt!
  createdAtBlock: BigInt!
  revokedAt: BigInt
  revokedAtBlock: BigInt
  transactionHash: Bytes!
}

type UserJoinTime @entity(immutable: false) {
  id: String! # eligibilityModule-user
  eligibilityModule: EligibilityModuleContract!
  user: Bytes!
  joinTime: BigInt!
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

enum VouchingRestrictionType {
  RateLimit
  NewUser
}

type VouchingRestrictionEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  eligibilityModule: EligibilityModuleContract!
  user: Bytes!
  userUser: User
  userUsername: String
  restrictionType: VouchingRestrictionType!
  eventAt: BigInt!
  eventAtBlock: BigInt!
  transactionHash: Bytes!
}

type HatAutoMintEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  eligibilityModule: EligibilityModuleContract!
  wearer: Bytes!
  wearerUser: User
  wearerUsername: String
  hatId: BigInt!
  hat: Hat
  vouchCount: Int!
  mintedAt: BigInt!
  mintedAtBlock: BigInt!
  transactionHash: Bytes!
}

type HatClaimEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  eligibilityModule: EligibilityModuleContract!
  wearer: Bytes!
  wearerUser: User
  wearerUsername: String
  hatId: BigInt!
  hat: Hat
  claimedAt: BigInt!
  claimedAtBlock: BigInt!
  transactionHash: Bytes!
}

type HatMetadataUpdateEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  eligibilityModule: EligibilityModuleContract!
  hat: Hat!
  hatId: BigInt!
  name: String!
  metadataCID: Bytes!
  updatedBy: Bytes!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ParticipationToken Entities

type ParticipationTokenContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization! # Organization this ParticipationTokenContract belongs to
  name: String!
  symbol: String!
  totalSupply: BigInt!
  executor: Bytes!
  hatsContract: Bytes!
  taskManagerAddress: Bytes
  educationHubAddress: Bytes
  createdAt: BigInt!
  createdAtBlock: BigInt!
  tokenRequests: [TokenRequest!]! @derivedFrom(field: "participationToken")
  balances: [TokenBalance!]! @derivedFrom(field: "participationToken")
}

enum TokenRequestStatus {
  Pending
  Approved
  Cancelled
}

type TokenRequest @entity(immutable: false) {
  id: String! # participationToken-requestId
  requestId: BigInt!
  participationToken: ParticipationTokenContract!
  requester: Bytes!
  requesterUser: User
  requesterUsername: String
  amount: BigInt!
  ipfsHash: String!
  status: TokenRequestStatus!
  approver: Bytes
  approverUser: User
  approverUsername: String
  createdAt: BigInt!
  createdAtBlock: BigInt!
  approvedAt: BigInt
  approvedAtBlock: BigInt
  cancelledAt: BigInt
  cancelledAtBlock: BigInt
  transactionHash: Bytes!
}

type TokenBalance @entity(immutable: false) {
  id: String! # participationToken-account
  participationToken: ParticipationTokenContract!
  account: Bytes!
  balance: BigInt!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
}

# QuickJoin Entities

type QuickJoinContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization! # Organization this QuickJoinContract belongs to
  executor: Bytes!
  hatsContract: Bytes!
  accountRegistry: Bytes!
  masterDeployAddress: Bytes!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  joinEvents: [QuickJoinEvent!]! @derivedFrom(field: "quickJoin")
}

type QuickJoinEvent @entity(immutable: true) {
  id: String! # quickJoin-txHash-logIndex
  quickJoin: QuickJoinContract!
  user: Bytes!
  userUser: User
  userUsername: String
  master: Bytes # only set for QuickJoinedByMaster events
  masterUsername: String
  usernameCreated: Boolean!
  hatIds: [BigInt!]!
  isMasterDeployJoin: Boolean! # true if joined by master, false if self-join
  joinedAt: BigInt!
  joinedAtBlock: BigInt!
  transactionHash: Bytes!
}

type QuickJoinAddressUpdate @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  quickJoin: QuickJoinContract!
  hatsContract: Bytes!
  accountRegistry: Bytes!
  masterDeployAddress: Bytes!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# EducationHub Contract and Related Entities
# ========================================

type EducationHubContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization!
  token: Bytes! # ParticipationToken address
  hatsContract: Bytes!
  executor: Bytes!
  isPaused: Boolean!
  nextModuleId: BigInt!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  modules: [EducationModule!]! @derivedFrom(field: "educationHub")
  completions: [ModuleCompletion!]! @derivedFrom(field: "educationHub")
  tokenChanges: [EducationHubTokenChange!]! @derivedFrom(field: "educationHub")
  hatsChanges: [EducationHubHatsChange!]! @derivedFrom(field: "educationHub")
}

enum ModuleStatus {
  Active
  Removed
}

type EducationModule @entity(immutable: false) {
  id: String! # educationHub-moduleId
  educationHub: EducationHubContract!
  moduleId: BigInt!
  title: String! # module title
  contentHash: Bytes! # content hash for the module materials
  payout: BigInt!
  status: ModuleStatus!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  updatedAt: BigInt
  updatedAtBlock: BigInt
  removedAt: BigInt
  removedAtBlock: BigInt
  completions: [ModuleCompletion!]! @derivedFrom(field: "module")
  updates: [ModuleUpdate!]! @derivedFrom(field: "module")
}

type ModuleCompletion @entity(immutable: true) {
  id: String! # educationHub-moduleId-learner
  educationHub: EducationHubContract!
  module: EducationModule!
  moduleId: BigInt!
  learner: Bytes!
  learnerUser: User
  learnerUsername: String
  completedAt: BigInt!
  completedAtBlock: BigInt!
  transactionHash: Bytes!
}

type ModuleUpdate @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  module: EducationModule!
  moduleId: BigInt!
  title: String!
  contentHash: Bytes!
  payout: BigInt!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
}

type EducationHubTokenChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  educationHub: EducationHubContract!
  newToken: Bytes!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

type EducationHubHatsChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  educationHub: EducationHubContract!
  newHats: Bytes!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# PaymentManager Contract and Related Entities
# ========================================

type PaymentManagerContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization!
  owner: Bytes!
  revenueShareToken: Bytes!
  distributionCounter: BigInt!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  distributions: [Distribution!]! @derivedFrom(field: "paymentManager")
  payments: [Payment!]! @derivedFrom(field: "paymentManager")
  claims: [Claim!]! @derivedFrom(field: "paymentManager")
  optOuts: [OptOutToggle!]! @derivedFrom(field: "paymentManager")
  ownershipTransfers: [OwnershipTransfer!]! @derivedFrom(field: "paymentManager")
  revenueShareTokenChanges: [RevenueShareTokenChange!]! @derivedFrom(field: "paymentManager")
}

enum DistributionStatus {
  Active
  Finalized
}

type Distribution @entity(immutable: false) {
  id: String! # paymentManager-distributionId
  paymentManager: PaymentManagerContract!
  distributionId: BigInt!
  payoutToken: Bytes!
  totalAmount: BigInt!
  checkpointBlock: BigInt!
  merkleRoot: Bytes!
  totalClaimed: BigInt!
  status: DistributionStatus!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  finalizedAt: BigInt
  finalizedAtBlock: BigInt
  unclaimedAmount: BigInt # Amount returned when finalized
  claims: [Claim!]! @derivedFrom(field: "distribution")
}

type Claim @entity(immutable: true) {
  id: String! # paymentManager-distributionId-claimer-txHash
  paymentManager: PaymentManagerContract!
  distribution: Distribution!
  distributionId: BigInt!
  claimer: Bytes!
  claimerUser: User
  claimerUsername: String
  amount: BigInt!
  claimedAt: BigInt!
  claimedAtBlock: BigInt!
  transactionHash: Bytes!
}

type Payment @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  paymentManager: PaymentManagerContract!
  payer: Bytes!
  payerUser: User
  payerUsername: String
  amount: BigInt!
  token: Bytes! # Address.zero() for native ETH
  receivedAt: BigInt!
  receivedAtBlock: BigInt!
  transactionHash: Bytes!
}

type OptOutToggle @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  paymentManager: PaymentManagerContract!
  user: Bytes!
  optedOut: Boolean!
  toggledAt: BigInt!
  toggledAtBlock: BigInt!
  transactionHash: Bytes!
}

type OwnershipTransfer @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  paymentManager: PaymentManagerContract!
  previousOwner: Bytes!
  newOwner: Bytes!
  transferredAt: BigInt!
  transferredAtBlock: BigInt!
  transactionHash: Bytes!
}

type RevenueShareTokenChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  paymentManager: PaymentManagerContract!
  newToken: Bytes!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# Universal Account Registry (Singleton)
# ========================================

type UniversalAccountRegistry @entity(immutable: false) {
  id: Bytes! # contract address (singleton)
  owner: Bytes!
  totalAccounts: BigInt!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  accounts: [Account!]! @derivedFrom(field: "registry")
  usernameChanges: [UsernameChange!]! @derivedFrom(field: "registry")
  accountDeletions: [AccountDeletion!]! @derivedFrom(field: "registry")
  batchRegistrations: [BatchRegistration!]! @derivedFrom(field: "registry")
  ownershipTransfers: [RegistryOwnershipTransfer!]! @derivedFrom(field: "registry")
}

type Account @entity(immutable: false) {
  id: Bytes! # user address
  registry: UniversalAccountRegistry!
  user: Bytes! # user address (same as id)
  username: String!
  isDeleted: Boolean!
  registeredAt: BigInt!
  registeredAtBlock: BigInt!
  lastUpdatedAt: BigInt!
  deletedAt: BigInt
  deletedAtBlock: BigInt
  users: [User!]! @derivedFrom(field: "account")
  usernameChanges: [UsernameChange!]! @derivedFrom(field: "account")
}

type UsernameChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  registry: UniversalAccountRegistry!
  account: Account!
  user: Bytes!
  oldUsername: String
  newUsername: String!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

type AccountDeletion @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  registry: UniversalAccountRegistry!
  user: Bytes!
  username: String!
  deletedAt: BigInt!
  deletedAtBlock: BigInt!
  transactionHash: Bytes!
}

type BatchRegistration @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  registry: UniversalAccountRegistry!
  count: BigInt!
  registeredAt: BigInt!
  registeredAtBlock: BigInt!
  transactionHash: Bytes!
}

type RegistryOwnershipTransfer @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  registry: UniversalAccountRegistry!
  previousOwner: Bytes!
  newOwner: Bytes!
  transferredAt: BigInt!
  transferredAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# Executor Contract and Related Entities
# ========================================

type ExecutorContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization! # Organization this ExecutorContract belongs to
  owner: Bytes!
  allowedCaller: Bytes # The governance contract authorized to call execute
  hatsContract: Bytes!
  isPaused: Boolean!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  callerChanges: [CallerChange!]! @derivedFrom(field: "executor")
  batchExecutions: [BatchExecution!]! @derivedFrom(field: "executor")
  sweeps: [ExecutorSweep!]! @derivedFrom(field: "executor")
  minterAuthorizations: [HatMinterAuthorization!]! @derivedFrom(field: "executor")
  hatsMintedEvents: [HatsMintedEvent!]! @derivedFrom(field: "executor")
  ownershipTransfers: [ExecutorOwnershipTransfer!]! @derivedFrom(field: "executor")
}

type CallerChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  executor: ExecutorContract!
  newCaller: Bytes!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

type BatchExecution @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  executor: ExecutorContract!
  proposalId: BigInt!
  callCount: BigInt!
  # Link to proposal if it exists (may be from HybridVoting or DirectDemocracy)
  hybridProposal: Proposal
  ddvProposal: DDVProposal
  executedAt: BigInt!
  executedAtBlock: BigInt!
  transactionHash: Bytes!
  calls: [CallExecution!]! @derivedFrom(field: "batch")
}

type CallExecution @entity(immutable: true) {
  id: Bytes! # txHash-logIndex-callIndex
  batch: BatchExecution!
  executor: ExecutorContract!
  proposalId: BigInt!
  callIndex: BigInt!
  target: Bytes!
  value: BigInt!
  executedAt: BigInt!
  executedAtBlock: BigInt!
  transactionHash: Bytes!
}

type ExecutorSweep @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  executor: ExecutorContract!
  to: Bytes!
  amount: BigInt!
  sweptAt: BigInt!
  sweptAtBlock: BigInt!
  transactionHash: Bytes!
}

type HatMinterAuthorization @entity(immutable: false) {
  id: String! # executor-minter
  executor: ExecutorContract!
  minter: Bytes!
  authorized: Boolean!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
}

type HatsMintedEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  executor: ExecutorContract!
  recipient: Bytes!
  recipientUser: User
  recipientUsername: String
  recipientAccount: Account # Link to global account
  hatIds: [BigInt!]!
  mintedAt: BigInt!
  mintedAtBlock: BigInt!
  transactionHash: Bytes!
}

type ExecutorOwnershipTransfer @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  executor: ExecutorContract!
  previousOwner: Bytes!
  newOwner: Bytes!
  transferredAt: BigInt!
  transferredAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# ToggleModule Contract and Related Entities
# ========================================

type ToggleModuleContract @entity(immutable: false) {
  id: Bytes! # contract address
  organization: Organization! # Organization this ToggleModuleContract belongs to
  admin: Bytes!
  eligibilityModule: Bytes # Reference to the eligibility module that can also toggle
  createdAt: BigInt!
  createdAtBlock: BigInt!
  hatToggles: [HatToggleEvent!]! @derivedFrom(field: "toggleModule")
  adminTransfers: [ToggleAdminTransfer!]! @derivedFrom(field: "toggleModule")
}

type HatToggleEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  toggleModule: ToggleModuleContract!
  hatId: BigInt!
  newStatus: Boolean! # true = active, false = inactive
  toggledAt: BigInt!
  toggledAtBlock: BigInt!
  transactionHash: Bytes!
}

type ToggleAdminTransfer @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  toggleModule: ToggleModuleContract!
  oldAdmin: Bytes!
  newAdmin: Bytes!
  transferredAt: BigInt!
  transferredAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# Consolidated Entities (replacing redundant contract-specific entities)
# ========================================

"""
Unified hat permission entity tracking all hat-based permissions across contracts.
Replaces: HybridVotingHatPermission, DirectDemocracyVotingHatPermission,
DirectDemocracyVotingCreatorHatPermission, ParticipationTokenMemberHat,
ParticipationTokenApproverHat, QuickJoinMemberHat, EducationHubCreatorHat,
EducationHubMemberHat
"""
type HatPermission @entity(immutable: false) {
  id: String! # contractAddress-hatId-role
  contractAddress: Bytes!
  contractType: ContractType!
  organization: Organization!
  hatId: BigInt!
  role: Role # Link back to Role entity
  permissionRole: HatPermissionRole!
  allowed: Boolean!
  hatType: Int # For HybridVoting/DDV (0=creator, 1+=voter classes)
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

"""
Unified executor change event tracking across all contracts that have an executor.
Replaces: HybridVotingExecutorChange, DirectDemocracyVotingExecutorChange,
EducationHubExecutorChange, QuickJoinExecutorChange
"""
type ExecutorChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  contractAddress: Bytes!
  contractType: ContractType!
  organization: Organization!
  newExecutor: Bytes!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

"""
Unified pause/unpause event tracking across all pausable contracts.
Replaces: ExecutorPauseEvent, EducationHubPauseEvent
"""
type PauseEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  contractAddress: Bytes!
  contractType: ContractType!
  organization: Organization!
  isPaused: Boolean! # true = paused, false = unpaused
  account: Bytes!
  eventAt: BigInt!
  eventAtBlock: BigInt!
  transactionHash: Bytes!
}

"""
Tracks hat changes for a user within an organization.
"""
type UserHatChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  user: User!
  hatId: BigInt!
  added: Boolean! # true = hat added, false = hat removed
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# PaymasterHub Contract and Related Entities
# ERC-4337 Paymaster for gas sponsorship across organizations
# ========================================

# Enums for PaymasterHub event types
enum DepositEventType {
  HubDeposit
  HubWithdraw
  OrgDeposit
  EmergencyWithdraw
}

enum BountyEventType {
  Funded
  Paid
  PayFailed
  Swept
}

enum SolidarityEventType {
  FeeCollected
  DonationReceived
  OrgBanned
  OrgUnbanned
}

enum ConfigChangeType {
  OrgRegistered
  OperatorHatSet
  FeeCapsSet
  PauseSet
  RuleSet
  BudgetSet
  BountyConfigSet
}

# 1. PaymasterHubContract - Singleton contract entity
type PaymasterHubContract @entity(immutable: false) {
  id: Bytes! # contract address
  entryPoint: Bytes!
  hats: Bytes!
  poaManager: Bytes!
  totalDeposit: BigInt!
  bountyPoolBalance: BigInt!
  solidarityBalance: BigInt!
  gracePeriodDays: Int!
  maxSpendDuringGrace: BigInt!
  minDepositRequired: BigInt!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
  # Derived relationships
  orgConfigs: [PaymasterOrgConfig!]! @derivedFrom(field: "paymasterHub")
  depositEvents: [PaymasterDepositEvent!]! @derivedFrom(field: "paymasterHub")
  bountyEvents: [BountyEvent!]! @derivedFrom(field: "paymasterHub")
  userOpEvents: [UserOpEvent!]! @derivedFrom(field: "paymasterHub")
  solidarityEvents: [SolidarityEvent!]! @derivedFrom(field: "paymasterHub")
  configChanges: [PaymasterConfigChange!]! @derivedFrom(field: "paymasterHub")
  gracePeriodChanges: [GracePeriodChange!]! @derivedFrom(field: "paymasterHub")
}

# 2. PaymasterOrgConfig - Per-organization configuration
type PaymasterOrgConfig @entity(immutable: false) {
  id: String! # paymasterHub-orgId
  paymasterHub: PaymasterHubContract!
  organization: Organization # Optional link to existing org
  orgId: Bytes!
  adminHatId: BigInt!
  operatorHatId: BigInt!
  isPaused: Boolean!
  isBannedFromSolidarity: Boolean!
  depositBalance: BigInt!
  totalDeposited: BigInt!
  totalSpent: BigInt!
  registeredAt: BigInt!
  registeredAtBlock: BigInt!
  transactionHash: Bytes!
  # Derived relationships
  rules: [PaymasterRule!]! @derivedFrom(field: "orgConfig")
  budgets: [PaymasterBudget!]! @derivedFrom(field: "orgConfig")
  feeCaps: PaymasterFeeCaps @derivedFrom(field: "orgConfig")
  bountyConfig: PaymasterBountyConfig @derivedFrom(field: "orgConfig")
  stats: PaymasterOrgStats @derivedFrom(field: "orgConfig")
  usageEvents: [UsageEvent!]! @derivedFrom(field: "orgConfig")
  depositEvents: [PaymasterDepositEvent!]! @derivedFrom(field: "orgConfig")
  configChanges: [PaymasterConfigChange!]! @derivedFrom(field: "orgConfig")
  pauseToggles: [PauseToggle!]! @derivedFrom(field: "orgConfig")
  banRecords: [OrgBanRecord!]! @derivedFrom(field: "orgConfig")
}

# 3. PaymasterRule - Target/selector permissions
type PaymasterRule @entity(immutable: false) {
  id: String! # paymasterHub-orgId-target-selector
  orgConfig: PaymasterOrgConfig!
  target: Bytes!
  selector: Bytes! # bytes4
  allowed: Boolean!
  maxCallGasHint: Int!
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

"""
Budget for a specific subject (user account or hat role).
subjectKey = keccak256(abi.encodePacked(subjectType, subjectId))
- subjectType 0x00 = account (subjectId is user address)
- subjectType 0x01 = hat (subjectId is hat ID as bytes20)
"""
# 4. PaymasterBudget - Per-subject spending limits
type PaymasterBudget @entity(immutable: false) {
  id: String! # paymasterHub-orgId-subjectKey
  orgConfig: PaymasterOrgConfig!
  subjectKey: Bytes! # keccak256 hash of (subjectType, subjectId)
  capPerEpoch: BigInt! # Max gas cost per epoch
  usedInEpoch: BigInt! # Current epoch usage
  epochLen: Int! # Epoch duration in seconds
  epochStart: Int! # Current epoch start timestamp
  totalUsed: BigInt! # Lifetime total
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

# 5. PaymasterFeeCaps - Per-org fee limits
type PaymasterFeeCaps @entity(immutable: false) {
  id: String! # paymasterHub-orgId
  orgConfig: PaymasterOrgConfig!
  maxFeePerGas: BigInt!
  maxPriorityFeePerGas: BigInt!
  maxCallGas: Int!
  maxVerificationGas: Int!
  maxPreVerificationGas: Int!
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

# 6. PaymasterBountyConfig - Per-org bounty settings
type PaymasterBountyConfig @entity(immutable: false) {
  id: String! # paymasterHub-orgId
  orgConfig: PaymasterOrgConfig!
  enabled: Boolean!
  maxBountyPerOp: BigInt!
  pctBpCap: Int!
  totalPaid: BigInt!
  setAt: BigInt!
  setAtBlock: BigInt!
  transactionHash: Bytes!
}

"""
Pre-computed aggregate statistics for an organization's paymaster usage.
Updated on each sponsored operation for efficient querying.
"""
# 7. PaymasterOrgStats - Aggregated statistics per org
type PaymasterOrgStats @entity(immutable: false) {
  id: String! # paymasterHub-orgId (same as PaymasterOrgConfig)
  orgConfig: PaymasterOrgConfig!
  # Operation counts
  totalUserOps: BigInt!
  totalSuccessfulBounties: BigInt!
  totalFailedBounties: BigInt!
  # Gas statistics
  totalGasSponsored: BigInt! # Sum of all gas costs sponsored
  # Financial
  totalDeposited: BigInt!
  totalWithdrawn: BigInt!
  totalBountyPaid: BigInt!
  totalSolidarityFeesCollected: BigInt!
  # Time tracking
  lastOperationAt: BigInt!
  lastOperationAtBlock: BigInt!
}

# ========================================
# PaymasterHub Immutable Event Records
# ========================================

# 8. PaymasterDepositEvent - Deposit and withdrawal history
type PaymasterDepositEvent @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  paymasterHub: PaymasterHubContract!
  orgConfig: PaymasterOrgConfig # null for hub-level events
  eventType: DepositEventType!
  from: Bytes
  to: Bytes
  amount: BigInt!
  newBalance: BigInt
  eventAt: BigInt!
  eventAtBlock: BigInt!
  transactionHash: Bytes!
}

# 9. BountyEvent - Bounty pool activity history
type BountyEvent @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  paymasterHub: PaymasterHubContract!
  orgConfig: PaymasterOrgConfig
  eventType: BountyEventType!
  userOpHash: Bytes
  recipient: Bytes
  amount: BigInt!
  newBalance: BigInt
  eventAt: BigInt!
  eventAtBlock: BigInt!
  transactionHash: Bytes!
}

# 10. UsageEvent - Gas usage tracking
type UsageEvent @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  orgConfig: PaymasterOrgConfig!
  budget: PaymasterBudget
  subjectKey: Bytes!
  delta: BigInt!
  usedInEpoch: BigInt!
  epochStart: Int!
  eventAt: BigInt!
  eventAtBlock: BigInt!
  transactionHash: Bytes!
}

# 11. UserOpEvent - UserOperation posting history
type UserOpEvent @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  paymasterHub: PaymasterHubContract!
  opHash: Bytes!
  postedBy: Bytes!
  eventAt: BigInt!
  eventAtBlock: BigInt!
  transactionHash: Bytes!
}

# 12. SolidarityEvent - Solidarity pool activity
type SolidarityEvent @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  paymasterHub: PaymasterHubContract!
  orgConfig: PaymasterOrgConfig
  eventType: SolidarityEventType!
  from: Bytes
  amount: BigInt
  eventAt: BigInt!
  eventAtBlock: BigInt!
  transactionHash: Bytes!
}

# 13. PaymasterConfigChange - Configuration change audit trail
type PaymasterConfigChange @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  paymasterHub: PaymasterHubContract!
  orgConfig: PaymasterOrgConfig
  changeType: ConfigChangeType!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# 14. GracePeriodChange - Grace period configuration history
type GracePeriodChange @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  paymasterHub: PaymasterHubContract!
  initialGraceDays: Int!
  maxSpendDuringGrace: BigInt!
  minDepositRequired: BigInt!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# 15. PauseToggle - Org pause state history
type PauseToggle @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  orgConfig: PaymasterOrgConfig!
  paused: Boolean!
  toggledAt: BigInt!
  toggledAtBlock: BigInt!
  transactionHash: Bytes!
}

# 16. OrgBanRecord - Solidarity ban history
type OrgBanRecord @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  orgConfig: PaymasterOrgConfig!
  banned: Boolean!
  bannedAt: BigInt!
  bannedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# OrgRegistry Contract and Related Entities
# ========================================

type OrgRegistryContract @entity(immutable: false) {
  id: Bytes! # contract address (singleton)
  totalOrgs: BigInt!
  totalContracts: BigInt!
  createdAt: BigInt!
  createdAtBlock: BigInt!
  registeredContracts: [RegisteredContract!]! @derivedFrom(field: "orgRegistry")
}

type OrgMetaUpdate @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  organization: Organization!
  orgId: Bytes!
  newName: String!
  newMetadataHash: Bytes!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
}

"""
IPFS-indexed org metadata content.
This entity is populated by a file data source that fetches from IPFS.
If IPFS is unavailable or slow, the main Organization entity will still be indexed
with the metadataHash - this entity will be populated when/if IPFS content becomes available.
"""
type OrgMetadata @entity(immutable: false) {
  id: String! # IPFS hash (CID)
  organization: Organization
  description: String
  template: String
  links: [OrgMetadataLink!]! @derivedFrom(field: "metadata")
  indexedAt: BigInt
}

type OrgMetadataLink @entity(immutable: true) {
  id: String! # metadataId-index
  metadata: OrgMetadata!
  name: String!
  url: String!
  index: Int!
}

type HatMetadata @entity(immutable: false) {
  id: String! # IPFS hash (CID)
  hat: Hat
  name: String # Role name fetched from IPFS JSON
  description: String # Fetched from IPFS JSON
  indexedAt: BigInt
}

type RegisteredContract @entity(immutable: false) {
  id: Bytes! # contractId (keccak256(orgId, typeId))
  orgRegistry: OrgRegistryContract!
  organization: Organization!
  orgId: Bytes!
  typeId: Bytes! # module type identifier
  proxy: Bytes! # BeaconProxy address
  beacon: Bytes! # Beacon address
  autoUpgrade: Boolean! # current auto-upgrade status
  owner: Bytes! # module owner
  registeredAt: BigInt!
  registeredAtBlock: BigInt!
  lastUpdatedAt: BigInt!
  transactionHash: Bytes!
  autoUpgradeChanges: [AutoUpgradeChange!]! @derivedFrom(field: "contract")
}

type AutoUpgradeChange @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  orgRegistry: OrgRegistryContract!
  contract: RegisteredContract!
  contractId: Bytes!
  enabled: Boolean!
  changedAt: BigInt!
  changedAtBlock: BigInt!
  transactionHash: Bytes!
}

# ========================================
# PoaManager Contract and Related Entities
# ========================================

type PoaManagerContract @entity(immutable: false) {
  id: Bytes! # contract address (singleton)
  registry: Bytes! # Current ImplementationRegistry address
  beaconCount: BigInt! # Total number of beacons created
  createdAt: BigInt!
  createdAtBlock: BigInt!
  beacons: [Beacon!]! @derivedFrom(field: "poaManager")
  beaconUpgrades: [BeaconUpgradeEvent!]! @derivedFrom(field: "poaManager")
  registryUpdates: [RegistryUpdate!]! @derivedFrom(field: "poaManager")
  # Infrastructure proxy addresses (populated via InfrastructureDeployed event)
  orgDeployerProxy: Bytes # OrgDeployer proxy contract address
  orgRegistryProxy: Bytes # OrgRegistry proxy contract address
  paymasterHubProxy: Bytes # PaymasterHub proxy contract address
  globalAccountRegistryProxy: Bytes # UniversalAccountRegistry proxy contract address
  passkeyAccountFactoryProxy: Bytes # PasskeyAccountFactory proxy contract address
}

type Beacon @entity(immutable: false) {
  id: String! # typeId (bytes32 as hex string for readability)
  poaManager: PoaManagerContract!
  typeId: Bytes! # bytes32 type identifier
  typeName: String! # Human-readable type name (e.g., "TaskManager", "HybridVoting")
  beaconAddress: Bytes! # UpgradeableBeacon contract address
  currentImplementation: Bytes! # Current implementation address
  version: String! # Current version (starts at "v1")
  createdAt: BigInt!
  createdAtBlock: BigInt!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
  upgrades: [BeaconUpgradeEvent!]! @derivedFrom(field: "beacon")
}

type BeaconUpgradeEvent @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  poaManager: PoaManagerContract!
  beacon: Beacon!
  typeId: Bytes!
  newImplementation: Bytes!
  version: String!
  upgradedAt: BigInt!
  upgradedAtBlock: BigInt!
  transactionHash: Bytes!
}

type RegistryUpdate @entity(immutable: true) {
  id: Bytes! # txHash-logIndex
  poaManager: PoaManagerContract!
  oldRegistry: Bytes!
  newRegistry: Bytes!
  updatedAt: BigInt!
  updatedAtBlock: BigInt!
  transactionHash: Bytes!
}

# 
#                    PASSKEY ACCOUNT ENTITIES
# 

type PasskeyAccountFactory @entity(immutable: false) {
  id: Bytes! # Factory contract address
  executor: Bytes!
  accountBeacon: Bytes!
  organizations: [PasskeyOrgConfig!]! @derivedFrom(field: "factory")
  accounts: [PasskeyAccount!]! @derivedFrom(field: "factory")
  createdAt: BigInt!
  blockNumber: BigInt!
}

type PasskeyOrgConfig @entity(immutable: false) {
  id: String! # orgId as hex string
  factory: PasskeyAccountFactory!
  orgId: Bytes!
  maxCredentialsPerAccount: Int!
  defaultGuardian: Bytes!
  recoveryDelay: BigInt!
  enabled: Boolean!
  createdAt: BigInt!
  updatedAt: BigInt!
}

type PasskeyAccount @entity(immutable: false) {
  id: Bytes! # Account contract address
  factory: PasskeyAccountFactory!
  orgId: Bytes!
  owner: Bytes! # Address that triggered creation
  guardian: Bytes!
  recoveryDelay: BigInt!
  credentials: [PasskeyCredential!]! @derivedFrom(field: "account")
  recoveryRequests: [RecoveryRequest!]! @derivedFrom(field: "account")
  executions: [PasskeyExecution!]! @derivedFrom(field: "account")
  batchExecutions: [PasskeyBatchExecution!]! @derivedFrom(field: "account")
  guardianChanges: [GuardianChange!]! @derivedFrom(field: "account")
  quickJoinEvents: [PasskeyQuickJoin!]! @derivedFrom(field: "account")
  createdAt: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type PasskeyCredential @entity(immutable: false) {
  id: String! # account-credentialId
  account: PasskeyAccount!
  credentialId: Bytes!
  orgId: Bytes!
  publicKeyX: Bytes # Not emitted in event, but useful if available
  publicKeyY: Bytes # Not emitted in event, but useful if available
  active: Boolean!
  signCount: BigInt!
  createdAt: BigInt!
  removedAt: BigInt
  blockNumber: BigInt!
}

enum RecoveryStatus {
  PENDING
  COMPLETED
  CANCELLED
}

type RecoveryRequest @entity(immutable: false) {
  id: String! # account-recoveryId
  account: PasskeyAccount!
  recoveryId: Bytes!
  credentialId: Bytes!
  initiator: Bytes!
  executeAfter: BigInt!
  status: RecoveryStatus!
  completedAt: BigInt
  cancelledAt: BigInt
  createdAt: BigInt!
  blockNumber: BigInt!
}

type PasskeyExecution @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  account: PasskeyAccount!
  target: Bytes!
  value: BigInt!
  data: Bytes!
  result: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type PasskeyBatchExecution @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  account: PasskeyAccount!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type GuardianChange @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  account: PasskeyAccount!
  oldGuardian: Bytes!
  newGuardian: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# 
#                    QUICKJOIN PASSKEY ENTITIES
# 

type PasskeyQuickJoin @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  quickJoinContract: Bytes!
  account: PasskeyAccount!
  username: String!
  credentialId: Bytes!
  hatIds: [BigInt!]!
  master: Bytes # Only set for master deploy path
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# 
#                    PAYMASTER VOUCHER ENTITIES
# 

type PaymasterVouchConfig @entity(immutable: false) {
  id: String! # orgId as hex string
  orgId: Bytes!
  voucherHatId: BigInt!
  updatedAt: BigInt!
  blockNumber: BigInt!
}

type PaymasterVouch @entity(immutable: true) {
  id: Bytes! # txHash.concatI32(logIndex)
  orgId: Bytes!
  account: Bytes!
  voucher: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}
